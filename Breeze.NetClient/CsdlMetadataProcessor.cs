using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using Breeze.Core;

namespace Breeze.Metadata {
  class CsdlMetadataProcessor {
    
    public CsdlMetadataProcessor(MetadataStore store, String jsonMetadata) {
      var json = (JObject) JsonConvert.DeserializeObject(jsonMetadata);
      _schema = json["schema"];
      _namespace = (String) _schema["namespace"];

      var entityTypes = ToEnumerable( _schema["entityType"]).Cast<JObject>()
        .Select(ParseCsdlEntityType).ToList();
      var complexTypes = ToEnumerable( _schema["complexType"]).Cast<JObject>()
        .Select(ParseCsdlComplexType).ToList();
    }

    public EntityType ParseCsdlEntityType(JObject csdlEntityType) {
      var abstractVal = (String) csdlEntityType["abstract"];
      var baseTypeVal = (String) csdlEntityType["baseType"];
      var nameVal = (String)csdlEntityType["name"];

      var isAbstract = abstractVal == "true";
      var entityType = new EntityType {
        ShortName = nameVal
      };
      if (baseTypeVal != null) {
        var baseTypeInfo = ParseTypeName(baseTypeVal);
        var baseTypeName = baseTypeInfo.TypeName;
        entityType.BaseTypeName = baseTypeName;
        var baseEntityType = _metadataStore.GetEntityType(baseTypeName, true);
        if (baseEntityType == null) {
          CompleteParseCsdlEntityType(entityType, csdlEntityType, baseEntityType);
        } else {
          List<DeferredTypeInfo> deferrals;
          if (_deferredTypeMap.ContainsKey(baseTypeName)) {
            deferrals = _deferredTypeMap[baseTypeName];
          } else {
            deferrals = new List<DeferredTypeInfo>();
            _deferredTypeMap[baseTypeName] = deferrals;
          }
          deferrals.Add(new DeferredTypeInfo { EntityType=entityType, CsdlEntityType=csdlEntityType });
        }
      } else {
        CompleteParseCsdlEntityType(entityType, csdlEntityType, null);
      }
      // entityType may or may not have been added to the metadataStore at this point.
      return entityType;
    }

    private void CompleteParseCsdlEntityType(EntityType entityType, JObject csdlEntityType, EntityType baseEntityType) {
      var baseKeyNamesOnServer = new List<string>();
      if (baseEntityType != null) {
        entityType.BaseEntityType = baseEntityType;
        entityType.AutoGeneratedKeyType = baseEntityType.AutoGeneratedKeyType;
        baseKeyNamesOnServer = baseEntityType.KeyProperties.Select(dp => dp.NameOnServer).ToList();
        baseEntityType.DataProperties.ForEach(dp => {
          var newDp = new DataProperty(dp);
          newDp.IsInherited = true;
          entityType.AddDataProperty(dp);
        });
        baseEntityType.NavigationProperties.ForEach(np => {
          var newNp = new NavigationProperty(np);
          newNp.IsInherited = true;
          entityType.AddNavigationProperty(np);
        });
      }
      var keyVal = csdlEntityType["key"];
      var keyNamesOnServer = keyVal == null 
        ? new List<String>() 
        : ToEnumerable(keyVal["propertyRef"]).Select(x => (String) x["name"]).ToList();
      keyNamesOnServer.AddRange(baseKeyNamesOnServer);

      ToEnumerable(csdlEntityType["property"]).ForEach(csdlDataProp => {
        ParseCsdlDataProperty(entityType, (JObject) csdlDataProp, keyNamesOnServer);
      });

      ToEnumerable(csdlEntityType["navigationproperty"]).ForEach(csdlNavProp => {
        ParseCsdlNavigationProperty(entityType, (JObject)csdlNavProp);
      });
    }

    private DataProperty ParseCsdlDataProperty(EntityType parentEntityType, JObject csdlProperty, List<String> keyNamesOnServer) {
      DataProperty dp;
      var typeParts = ExtractTypeNameParts(csdlProperty);

      if (typeParts.Length == 2) {
        dp = ParseCsdlSimpleProperty(parentEntityType, csdlProperty, keyNamesOnServer);
      } else {
        if (IsEnumType(csdlProperty)) {
          dp = ParseCsdlSimpleProperty(parentEntityType, csdlProperty, keyNamesOnServer);
          dp.EnumTypeName = (String) csdlProperty["type"];
        } else {
          dp = ParseCsdlComplexProperty(parentEntityType, csdlProperty);
        }
      }

      if (dp != null) {
        parentEntityType.AddDataProperty(dp);
        AddValidators(dp);
      }
      return dp;
    }

    private DataProperty ParseCsdlSimpleProperty(EntityType parentEntityType, JObject csdlProperty, List<String> keyNamesOnServer) {
      
      var typeVal = (String) csdlProperty["type"];
      var nameVal = (String)csdlProperty["name"];
      var nullableVal = (String) csdlProperty["nullable"];
      var maxLengthVal = (String) csdlProperty["maxLength"];
      var concurrencyModeVal = (String)csdlProperty["concurrencyMode"];

      var dataType = DataType.FromEdmType(typeVal);
      if (dataType == DataType.Undefined) {
        parentEntityType.Warnings.Add("Unable to recognize DataType for property: " + nameVal + " DateType: " + typeVal);
      }
      
      var isNullable = nullableVal == "true" || nullableVal == null;
      var isPartOfKey = keyNamesOnServer != null && keyNamesOnServer.IndexOf( nameVal) >= 0;
      if (isPartOfKey && parentEntityType.AutoGeneratedKeyType == AutoGeneratedKeyType.None) {
        if (IsIdentityProperty(csdlProperty)) {
          parentEntityType.AutoGeneratedKeyType = AutoGeneratedKeyType.Identity;
        }
      }
      // TODO: nit - don't set maxLength if null;
      
      var maxLength = (maxLengthVal == null || maxLengthVal == "Max") ? (Int64?)null : Int64.Parse(maxLengthVal);
      var concurrencyMode = concurrencyModeVal == "fixed" ? ConcurrencyMode.Fixed : ConcurrencyMode.None;
      var dp = new DataProperty() {
        NameOnServer = nameVal,
        DataType = dataType,
        IsNullable = isNullable,
        IsPartOfKey = isPartOfKey,
        MaxLength = maxLength,
        DefaultValue = csdlProperty["defaultValue"],
        // fixedLength: fixedLength,
        ConcurrencyMode = concurrencyMode
      };

      if (dataType == DataType.Undefined) {
        dp.RawTypeName = typeVal;
      }
      return dp;
    }

    private DataProperty ParseCsdlComplexProperty(EntityType parentEntityType, JObject csdlProperty) {
      return null;
    }

    private DataProperty ParseCsdlNavigationProperty(EntityType parentEntityType, JObject csdlProperty) {

    //  function parseCsdlNavProperty(entityType, csdlProperty, schema) {
    //    var association = getAssociation(csdlProperty, schema);
    //    var toEnd = __arrayFirst(association.end, function (assocEnd) {
    //        return assocEnd.role === csdlProperty.toRole;
    //    });

    //    var isScalar = toEnd.multiplicity !== "*";
    //    var dataType = parseTypeName(toEnd.type, schema).typeName;

    //    var constraint = association.referentialConstraint;
    //    if (!constraint) {
    //        // TODO: Revisit this later - right now we just ignore many-many and assocs with missing constraints.
    //        return;
    //        // Think about adding this back later.
    //        //if (association.end[0].multiplicity == "*" && association.end[1].multiplicity == "*") {
    //        //    // many to many relation
    //        //    ???
    //        //} else {
    //        //    throw new Error("Foreign Key Associations must be turned on for this model");
    //        //}
    //    }
        
    //    var cfg = {
    //        nameOnServer: csdlProperty.name,
    //        entityTypeName: dataType,
    //        isScalar: isScalar,
    //        associationName: association.name
    //    };

    //    var principal = constraint.principal;
    //    var dependent = constraint.dependent;
        
    //    var propRefs = __toArray(dependent.propertyRef);
    //    var fkNames = propRefs.map(__pluck("name"));
    //    if (csdlProperty.fromRole === principal.role) {
    //        cfg.invForeignKeyNamesOnServer = fkNames;
    //    } else {
    //        // will be used later by np._update
    //        cfg.foreignKeyNamesOnServer = fkNames;
    //    }

    //    var np = new NavigationProperty(cfg);
    //    entityType.addProperty(np);
    //    return np;
    //}
      return null;
    }

    private JObject GetAssociation(JObject csdlNavProperty) {
      var assocsVal = _schema["association"];
      if (assocsVal == null) return null;
      
      var relationshipVal = (String) csdlNavProperty["relationship"];
      var assocName = ParseTypeName(relationshipVal).ShortTypeName;

      var association = ToEnumerable(assocsVal).FirstOrDefault(assoc => (String) assoc["name"] == assocName);
          
      return (JObject) association;
    }

   

    

    private ComplexType ParseCsdlComplexType(JObject csdlComplexType) {
      var nameVal = (String)csdlComplexType["name"];
      return new ComplexType {
        ShortName = nameVal
      };
    }


    private bool IsIdentityProperty(JObject csdlProperty) {

      var subProp = csdlProperty.Properties().FirstOrDefault(p => p.Name.IndexOf("StoreGeneratedPattern") > 0);
      if (subProp != null) {
        return subProp.Name == "Identity";
      } else {
        // see if Odata feed
        var extensionsVal = csdlProperty["extensions"];
        if (extensionsVal == null) return false;
        // TODO: NOT YET TESTED
        var identityExtn = ToEnumerable(extensionsVal).FirstOrDefault(extn => {
          return (String) extn["name"] == "StoreGeneratedPattern" && (String) extn["value"] == "Identity";
        });
        return identityExtn != null;
      }
    }
      

    private void AddValidators(DataProperty dp) {
      if (!dp.IsNullable) {
        // dp._validators.Add(Validator.Required);
      }

    }

    // function addValidators(dataProperty) {
    //    var typeValidator;
    //    if (!dataProperty.isNullable) {
    //        dataProperty.validators.push(Validator.required());
    //    }

    //    if (dataProperty.isComplexProperty) return;

    //    if (dataProperty.dataType === DataType.String) {
    //        if (dataProperty.maxLength) {
    //            var validatorArgs = { maxLength: dataProperty.maxLength };
    //            typeValidator = Validator.maxLength(validatorArgs);
    //        } else {
    //            typeValidator = Validator.string();
    //        }
    //    } else {
    //        typeValidator = dataProperty.dataType.validatorCtor();
    //    }

    //    dataProperty.validators.push(typeValidator);

    //}

    private bool IsEnumType(JObject csdlProperty) {
      var enumTypeVal = _schema["enumType"];
      if ( enumTypeVal == null) return false;
      var enumTypes = ToEnumerable(enumTypeVal);
      var typeParts = ExtractTypeNameParts(csdlProperty);
      var baseTypeName = typeParts[typeParts.Length - 1];
      return enumTypes.Any( enumType => ((String) enumType["name"] == baseTypeName));
    }

    private String[] ExtractTypeNameParts(JObject csdlProperty) {
        var typeParts = ((String)csdlProperty["type"]).Split('.');
        return typeParts;
    }

    private TypeNameInfo ParseTypeName(String entityTypeName) {
      if (String.IsNullOrEmpty(entityTypeName)) return null;
      if (entityTypeName.StartsWith(MetadataStore.ANONTYPE_PREFIX)) {
        return new TypeNameInfo() {
          ShortTypeName = entityTypeName,
          Namespace = "",
          TypeName = entityTypeName,
          IsAnonymous = true,
        };
      }

      var entityTypeNameNoAssembly = entityTypeName.Split(',')[0];
        var nameParts = entityTypeNameNoAssembly.Split('.');
      if (nameParts.Length > 1) {
        var shortName = nameParts[nameParts.Length - 1];
        var  nsParts =  nameParts.Take(nameParts.Length - 1).ToArray();
        var ns = String.Join(".", nsParts);
        //if (schema) {
        //    ns = getNamespaceFor(shortName, schema);
        //} else {
        //    var namespaceParts = nameParts.slice(0, nameParts.length - 1);
        //    ns = namespaceParts.join(".");
        //}
        return new TypeNameInfo() {
            ShortTypeName =  shortName,
            Namespace =  ns,
            TypeName =  QualifyTypeName(shortName, ns)
        };
      } else {
         return new TypeNameInfo() {
            ShortTypeName =  entityTypeName,
            Namespace =  "",
            TypeName =  entityTypeName
        };
      }
    }

    private String QualifyTypeName(String shortName, String ns) {
      return shortName + ":#" + ns;
    }

    private IEnumerable<T> ToEnumerable<T>(T d) {
      if (d == null) {
        return Enumerable.Empty<T>();
      } else if (d.GetType() == typeof(JArray)) {
        return ((IEnumerable)d).Cast<T>();
      } else {
        return new T[] { d };
      }
    }

    internal class TypeNameInfo {
      public String ShortTypeName { get; set; }
      public String Namespace { get; set; }
      public String TypeName { get; set; }
      public Boolean IsAnonymous { get; set; }
    }

    private class DeferredTypeInfo {
      public EntityType EntityType { get; set; }
      public JObject CsdlEntityType { get; set; }
    }

    private JToken _schema;
    private String _namespace;
    private MetadataStore _metadataStore;
    private Dictionary<String, List<DeferredTypeInfo>> _deferredTypeMap = new Dictionary<String, List<DeferredTypeInfo>>();



  }
}
