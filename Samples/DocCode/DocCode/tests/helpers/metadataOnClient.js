/********************************************************** 
 * Example of defining metadata on the client in JavaScript
 * Used by metadataTests.js
 **********************************************************/
(function (testFns) {
    "use strict";

    // Convenience variables

    var DT = breeze.DataType;
    var Identity = breeze.AutoGeneratedKeyType.Identity;
    var Validator = breeze.Validator;
    var camelCaseConvention = breeze.NamingConvention.camelCase;
    var defaultNamespace; // assigned in create...MetadataStore methods.

    testFns.metadataOnClient = {
        createDtoMetadataStore: createDtoMetadataStore,

        addCategoryType        : addCategoryType,
        addLocationComplexType : addLocationComplexType,
        addProductType         : addProductType, 
        addSupplierType        : addSupplierType,

        createProductMetadataStore: createProductMetadataStore,

        addCustomerDtoType    : addCustomerDtoType,   
        addOrderDtoType       : addOrderDtoType,      
        addOrderDetailDtoType : addOrderDetailDtoType,
        addProductDtoType     : addProductDtoType    
    };


    // Creates a metadataStore with 3 Northwind Product EntityTypes:
    // Product, Category, Supplier and a LocationComplexType
    function createProductMetadataStore(dataservice) {

        var store = createMetadataStore();

        addDataService(store, dataservice);

        defaultNamespace = testFns.northwindNamespace;

        // Add types in alphabetical order ... because we can
        addCategoryType(store);
        addLocationComplexType(store);
        addProductType(store);
        addSupplierType(store);
        
        return store;
    }

    //#region Category
    // A simple reference type
    function addCategoryType(store) {
        var et = {
            shortName: "Category",
            namespace: defaultNamespace,    // set by patchDefaults() in subsequent typeDefs
            autoGeneratedKeyType: Identity, // default is None
            defaultResourceName: "Categories",
            
            dataProperties: {
                categoryID:   { dataType: DT.Int32, isPartOfKey: true },
                categoryName: { maxLength: 4000 }, // DT.String is the default DataType
                description:  { maxLength: 4000 },
                picture:      { dataType: DT.Binary, maxLength: 4000},
                rowVersion:   { dataType: DT.Int32, isNullable: false },
            }
        };

        return et = addTypeToStore(store, et);
    }
    //#endregion

    //#region Location ComplexType
    function addLocationComplexType(store) {
        var et = {
            shortName: "Location",
            isComplexType: true,

            dataProperties: {
                address:    { maxLength: 60 },
                city:       { maxLength: 15 },
                region:     { maxLength: 15 },
                postalCode: { maxLength: 10 },
                country:    { maxLength: 15 },
            }
        };

        return et = addTypeToStore(store, et);
    }

    //#endregion

    //#region Product
    function addProductType(store) {
        var et = {
            shortName: "Product",
            autoGeneratedKeyType: Identity, 
            defaultResourceName: "Products",

            dataProperties: {
                productID:       { dataType: DT.Int32, isPartOfKey: true },
                productName:     { maxLength: 40 },
                supplierID:      { dataType: DT.Int32} ,
                categoryID:      { dataType: DT.Int32 },
                quantityPerUnit: { maxLength: 4000 },
                unitPrice:       { dataType: DT.Decimal },
                unitsInStock:    { dataType: DT.Int16 },
                unitsOnOrder:    { dataType: DT.Int16 },
                reorderLevel:    { dataType: DT.Int16 },
                discontinued:    { dataType: DT.Boolean, isNullable: false },
                discontinuedDate:{ dataType: DT.DateTime },
                rowVersion:      { dataType: DT.Int32, isNullable: false },
            },

            navigationProperties: {
                category: {
                    entityTypeName: "Category",
                    associationName: "Product_Category",
                    foreignKeyNames: ["categoryID"] 
                },
                supplier: {
                    entityTypeName: "Supplier",
                    associationName: "Supplier_Products",
                    foreignKeyNames: ["supplierID"] 
                },
            }
        };

        return et = addTypeToStore(store, et);
    }
    //#endregion

    //#region Supplier
    // Another simple reference type
    function addSupplierType(store) {
        var et = {
            shortName: "Supplier",
            autoGeneratedKeyType: Identity, 
            defaultResourceName: "Suppliers",

            custom: {style: "bold", meaningOfLife: 42},

            dataProperties: {
                supplierID:   { dataType: DT.Int32, isPartOfKey: true },
                companyName:  { maxLength: 40, isNullable: false, custom: {uiHint:"big"} },
                contactName:  { maxLength: 30 },
                contactTitle: { maxLength: 30 },
                location:     { complexTypeName: "Location", isNullable: false },

                /* if didn't have Location ComplexType
                address:      { maxLength: 60 },
                city:         { maxLength: 15 },
                region:       { maxLength: 15 },
                postalCode:   { maxLength: 10 },
                country:      { maxLength: 15 },
                */

                // example of embedding a validator in the metadata
                phone:        { maxLength: 24 , validators: [ Validator.phone() ] },                
                fax:          { maxLength: 24 },
                homePage:     { maxLength: 4000 },
                rowVersion:   { dataType: DT.Int32, isNullable: false },
            },

            navigationProperties: {
                products: {
                    entityTypeName: "Product",
                    isScalar: false,
                    associationName: "Supplier_Products",
                }
            }
        };

        return et = addTypeToStore(store, et);
    }
    //#endregion


    // Creates a metadataStore with NorthwindDto entity types:
    // Customer, Order, OrderDetail, Product
    function createDtoMetadataStore(dataservice) {

        var store = createMetadataStore();

        addDataService(store, dataservice);

        defaultNamespace = testFns.northwindDtoNamespace;

        // Add types in alphabetical order ... because we can
        addCustomerDtoType(store);
        addOrderDtoType(store);
        addOrderDetailDtoType(store);
        addProductDtoType(store);

        return store;
    }

    //#region CustomerDto
    function addCustomerDtoType(store) {
        var et = {
            shortName: "Customer",
            defaultResourceName: "Customers",

            dataProperties: {
                customerID:  { dataType: DT.Guid, isPartOfKey: true },
                companyName: { isNullable: false, maxLength: 40 },
            },

            navigationProperties: {
                orders: {
                    entityTypeName: "Order",
                    isScalar: false,
                    associationName: "Order_Customer",
                    invForeignKeyNames: ["customerID"] // in server def; shouldn't be necessary
                }
            }
        };

        return et = addTypeToStore(store, et);
    }

    //#endregion

    //#region OrderDto
    function addOrderDtoType(store) {
        var et = {
            shortName: "Order",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Orders",

            dataProperties: {
                orderID:      { dataType: DT.Int32, isPartOfKey: true },
                customerID:   { dataType: DT.Guid },
                orderDate:    { dataType: DT.DateTime },
                requiredDate: { dataType: DT.DateTime }, 
                shippedDate:  { dataType: DT.DateTime },
                freight:      { dataType: DT.Decimal },
                rowVersion:   { dataType: DT.Int32, isNullable: false }
            },

            navigationProperties: {
                customer: {
                    entityTypeName: "Customer",
                    associationName: "Order_Customer",
                    foreignKeyNames: ["customerID"] 
                },
                orderDetails: {
                    entityTypeName: "OrderDetail",
                    isScalar: false,
                    associationName: "OrderDetail_Order",
                    invForeignKeyNames: ["orderID"] // in server def; shouldn't be necessary
                }
            }
        };

        return et = addTypeToStore(store, et);
    }

    //#endregion

    //#region OrderDetailDto
    function addOrderDetailDtoType(store) {
        var et = {
            shortName: "OrderDetail",
            defaultResourceName: "OrderDetails",

            dataProperties: {
                orderID:    { dataType: DT.Int32, isPartOfKey: true },
                productID:  { dataType: DT.Int32, isPartOfKey: true },

                unitPrice:  { dataType: DT.Decimal, isNullable: false },
                quantity:   { dataType: DT.Int16, isNullable: false },
                discount:   { dataType: DT.Single, isNullable: false },
                rowVersion: { dataType: DT.Int32, isNullable: false }
            },

            navigationProperties: {
                order: {
                    entityTypeName: "Order",
                    associationName: "OrderDetail_Order",
                    foreignKeyNames: ["orderID"]
                },
                product: {
                    entityTypeName: "Product",
                    associationName: "OrderDetail_Product", // not needed but server version has it
                    foreignKeyNames: ["productID"]
                }

            }
        };

        return et = addTypeToStore(store, et);
    }

    //#endregion

    //#region ProductDto
    function addProductDtoType(store) {
        var et = {
            shortName: "Product",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Products",

            dataProperties: {
                productID: { dataType: DT.Int32, isPartOfKey: true },
                productName: { maxLength: 40, isNullable: false },
            },

        };

        return et = addTypeToStore(store, et);
    }
    //#endregion


    //#region Helper methods 

    function createMetadataStore() {
        return new breeze.MetadataStore({ namingConvention: camelCaseConvention });
    }


    function addDataService(store, serviceName) {
        store.addDataService(
                new breeze.DataService({ serviceName: serviceName })
        );
    }

    // Create the type from the definition hash and add the type to the store
    // fixes some defaults, infers certain validators,
    // add adds the type's "shortname" as a resource name
    function addTypeToStore(store, typeDef) {
        patchDefaults(typeDef);
        var type = typeDef.isComplexType ?
            new breeze.ComplexType(typeDef) :
            new breeze.EntityType(typeDef);
        store.addEntityType(type);
        inferValidators(type);
        addTypeNameAsResource(store, type);

        return type;
    }

    // Patch some defaults in the type definition object
    // Todo: consider moving these patches into breeze itself
    function patchDefaults(typeDef) {
        var typeName = typeDef.shortName;
        // if no namespace specified, assign the defaultNamespace 
        var namespace = typeDef.namespace = typeDef.namespace || defaultNamespace;
        var dps = typeDef.dataProperties;
        for (var key in dps) {
            if (_hasOwnProperty(dps, key)) {
                var prop = dps[key];
                if (prop.complexTypeName && prop.complexTypeName.indexOf(":#") === -1) {
                    // if complexTypeName is unqualified, suffix with the entity's own namespace
                    prop.complexTypeName += ':#' + namespace;
                }
                // assume key part is non-nullable ... unless explicitly declared nullable (when is that good?)
                prop.isNullable = prop.isNullable == null ? !prop.isPartOfKey : !!prop.isNullable;

                if (prop.validators) { convertValidators(typeName, key, prop); }
            }
        };
        
        var navs = typeDef.navigationProperties;
        for (var key in navs) {
            if (_hasOwnProperty(navs, key)) {
                var prop = navs[key];
                if (prop.entityTypeName.indexOf(":#") === -1) {
                    // if name is unqualified, suffix with the entity's own namespace
                    prop.entityTypeName += ':#' + namespace;
                }
            }
        };
    }


    // While Breeze requires that the validators collection be defined with Validator instances
    // we support alternative expression of validators in JSON form (as if coming from the server)
    // Validator:
    //    phone: { maxLength: 24, validators: [ Validator.phone() ] },
    // JSON:
    //    phone: { maxLength: 24, validators: [ {name: 'phone'} ] },                
    // This fn converts JSON to a Validator instance
    function convertValidators(typeName, propName, propDef) {
        var validators = propDef.validators;
        if (!_isArray(validators)) {
            throw "{0}.{1}.validators must be an array".format(typeName, propName);
        }

        var Validator = breeze.Validator;
        validators.forEach(function (val, ix) {
            if (val instanceof Validator) return;
            try {
                validators[ix]=Validator.fromJSON(val);
            } catch (ex) {
                throw "{0}.{1}.validators[{2}] = '{3}' can't be converted to a known Validator."
                    .format(typeName, propName, ix, JSON.stringify(val));
            }
        });
    }

    function inferValidators(entityType) {

        entityType.dataProperties.forEach(function (prop) {
            if (!prop.isNullable) { // is required. 
                addValidator(prop, Validator.required());
            };

            addValidator(prop, getDataTypeValidator(prop));

            if (prop.maxLength != null && prop.dataType === DT.String) {
                addValidator(prop, Validator.maxLength({ maxLength: prop.maxLength }));
            }

        });

        return entityType;

        function addValidator(prop, validator) {
            if (!validator) { return; } // no validator arg
            var valName = validator.name;
            var validators = prop.validators;
            var found = validators.filter(function (val) { return val.name == valName; })
            if (!found.length) { // this validator has not already been specified
                validators.push(validator);
            }
        }

        function getDataTypeValidator(prop) {
            var dataType = prop.dataType;
            var validatorCtor = !dataType || dataType === DT.String ? null : dataType.validatorCtor;
            return validatorCtor ? validatorCtor() : null;
        }
    }

    // Often helpful to have the type's 'shortName' available as a resource name 
    // as when composing a query to be executed locally against the cache.
    // This function adds the type's 'shortName' as one of the resource names for the type.
    // Theoretically two types in different models could have the same 'shortName'
    // and thus we would associate the same resource name with the two different types.
    // While unlikely, breeze should offer a way to remove a resource name for a type.
    function addTypeNameAsResource(store, type) {
        if (!type.isComplexType) {
            store.setEntityTypeForResourceName(type.shortName, type);
        }
    }

    function _hasOwnProperty(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key)
    }

    function _isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    }
    //#endregion

})(docCode.testFns);


//#region Imagining a DSL 

/**** Imagining a possible future DSL ****** 
// automatically infers validators

var et = ET("Category").ns(namespace).identityKeyed()
                       .resourceNames("Categories");

et.withProperties(
    DP("categoryID").i32().key().notNull(),
    DP("categoryName").maxLength(4000),
    DP("description").maxLength(4000),
    DP("picture").binary.maxLength(4000),
    DP("rowVersion").i32().notNull());

et.has("products").of("Product").inAssociation("Product_Category");

return et;

************/
//#endregion