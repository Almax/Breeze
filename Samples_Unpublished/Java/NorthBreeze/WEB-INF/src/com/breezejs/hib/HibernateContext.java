package com.breezejs.hib;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.hibernate.EntityMode;
import org.hibernate.FlushMode;
import org.hibernate.LockMode;
import org.hibernate.PropertyValueException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.metadata.ClassMetadata;
import org.hibernate.type.ComponentType;
import org.hibernate.type.Type;

import com.breezejs.save.*;

public class HibernateContext extends ContextProvider {

	private Map<String, Object> metadataMap;
	private Session session;
	private List<EntityError> entityErrors = new ArrayList<EntityError>();
	private Map<EntityInfo, KeyMapping> entityKeyMapping = new HashMap<EntityInfo, KeyMapping>();
	private RelationshipFixer fixer;

	/**
	 * @param session Hibernate session to be used for saving
	 * @param metadataMap metadata from MetadataBuilder
	 */
	public HibernateContext(Session session, Map<String, Object> metadataMap) {
		this.session = session;
		this.metadataMap = metadataMap;
	}
	
	/**
     * Allows subclasses to process entities before they are saved.  This method is called
     * after BeforeSaveEntities(saveMap), and before any session.Save methods are called.
     * The foreign-key associations on the entities have been resolved, relating the entities
     * to each other, and attaching proxies for other many-to-one associations.
	 * 
	 * @param entitiesToPersist List of entities in the order they will be saved
	 * @return The same entitiesToPersist.  Overrides of this method may modify the list.
	 */
	public List<EntityInfo> beforeSaveEntityGraph(List<EntityInfo> entitiesToPersist) {
		return entitiesToPersist;
	}

	protected void saveChangesCore(SaveWorkState saveWorkState) {
		Map<Class, List<EntityInfo>> saveMap = saveWorkState.saveMap;
		session.setFlushMode(FlushMode.NEVER);
		Transaction tx = session.getTransaction();
		boolean hasExistingTransaction = tx.isActive();
		if (!hasExistingTransaction)
			tx.begin();
		try {
			processSaves(saveMap);

			session.flush();
			//          RefreshFromSession(saveMap);
			if (!hasExistingTransaction)
				tx.commit();
			fixer.removeRelationships();
		} catch (PropertyValueException pve) {
			// NHibernate can throw this
			if (tx.isActive())
				tx.rollback();
			entityErrors.add(new EntityError("PropertyValueException", pve.getEntityName(), null,
					pve.getPropertyName(), pve.getMessage()));
			saveWorkState.entityErrors = entityErrors;
		} catch (Exception ex) {
			if (tx.isActive())
				tx.rollback();
			throw ex;
		} finally {
			//          if (!hasExistingTransaction) tx.Dispose();
		}

		saveWorkState.keyMappings = updateAutoGeneratedKeys(saveWorkState.entitiesWithAutoGeneratedKeys);
	}

	/**
	 * Persist the changes to the entities in the saveMap.
	 * @param saveMap
	 */
	private void processSaves(Map<Class, List<EntityInfo>> saveMap) {
		// Get the map of foreign key relationships
		Map<String, String> fkMap = (Map<String, String>) metadataMap.get(MetadataBuilder.FK_MAP);
		fixer = new RelationshipFixer(saveMap, fkMap, session);

		// Relate entities in the saveMap to other NH entities, so NH can save the FK values.
		List<EntityInfo> saveOrder = fixer.fixupRelationships();
		
		// Allow subclass to process entities before we save them
		saveOrder = beforeSaveEntityGraph(saveOrder);
		
		SessionFactory sf = session.getSessionFactory();
		for (EntityInfo entityInfo : saveOrder) {
	        Class entityType = entityInfo.entity.getClass();
	        ClassMetadata classMeta = sf.getClassMetadata(entityType);
	        addKeyMapping(entityInfo, entityType, classMeta);
	        processEntity(entityInfo, classMeta);
		}
	}

	/**
	 * Add, update, or delete the entity according to its EntityState.
	 * @param entityInfo
	 * @param classMeta
	 */
	private void processEntity(EntityInfo entityInfo, ClassMetadata classMeta) {
		Object entity = entityInfo.entity;
		EntityState state = entityInfo.entityState;

		// Restore the old value of the concurrency column so Hibernate will be able to save the entity
		if (classMeta.isVersioned()) {
			restoreOldVersionValue(entityInfo, classMeta);
		}

		if (state == EntityState.Modified) {
			session.update(entity);
		} else if (state == EntityState.Added) {
			session.save(entity);
		} else if (state == EntityState.Deleted) {
			session.delete(entity);
		} else {
			// Just re-associate the entity with the session.  Needed for many to many to get both ends into the session.
			session.lock(entity, LockMode.NONE);
		}
	}

	/**
	 * Record the value of the temporary key in EntityKeyMapping
	 * @param entityInfo
	 * @param type
	 * @param meta
	 */
	private void addKeyMapping(EntityInfo entityInfo, Class type, ClassMetadata meta) {
		if (entityInfo.entityState == EntityState.Added) {
			Object entity = entityInfo.entity;
			Object id = getIdentifier(entity, meta);
			KeyMapping km = new KeyMapping(type.getName(), id);
			entityKeyMapping.put(entityInfo, km);
		}
	}

	/**
	 * Get the identifier value for the entity.  If the entity does not have an
	 * identifier property, or natural identifiers defined, then the entity itself is returned.
	 * @param entity
	 * @param meta
	 * @return
	 */
	private Object getIdentifier(Object entity, ClassMetadata meta) {
		Class type = entity.getClass();
		if (meta == null)
			meta = session.getSessionFactory().getClassMetadata(type);

		Type idType = meta.getIdentifierType();
		if (idType != null) {
			Serializable id = meta.getIdentifier(entity);
			if (idType.isComponentType()) {
				ComponentType compType = (ComponentType) idType;
				return compType.getPropertyValues(id, EntityMode.POJO);
			} else {
				return id;
			}
		} else if (meta.hasNaturalIdentifier()) {
			int[] idprops = meta.getNaturalIdentifierProperties();
			Object[] values = meta.getPropertyValues(entity);
			Object[] idvalues = new Object[idprops.length];
			for (int i = 0; i < idprops.length; i++) {
				idvalues[i] = values[idprops[i]];
			}
			return idvalues;
		}
		return entity;
	}

	/**
	 * Get the identifier value for the entity as an object[].  This is needed for creating an EntityError.
	 * @param entity
	 * @param meta
	 * @return
	 */
	private Object[] getIdentifierAsArray(Object entity, ClassMetadata meta) {
		Object value = getIdentifier(entity, meta);
		if (value.getClass().isArray()) {
			return (Object[]) value;
		} else {
			return new Object[] { value };
		}
	}

	/**
	 * Restore the old value of the concurrency column so Hibernate will save the entity.
	 * Otherwise it will complain because Breeze has already changed the value.
	 * @param entityInfo
	 * @param classMeta
	 */
	private void restoreOldVersionValue(EntityInfo entityInfo, ClassMetadata classMeta) {
		if (entityInfo.originalValuesMap == null || entityInfo.originalValuesMap.size() == 0)
			return;
		int vcol = classMeta.getVersionProperty();
		String vname = classMeta.getPropertyNames()[vcol];
		Object oldVersion = entityInfo.originalValuesMap.get(vname);
		if (oldVersion != null) {
			Object entity = entityInfo.entity;
			//        Class vtype = classMeta.getPropertyTypes()[vcol].getReturnedClass();
			//        if (vtype != oldVersion.getClass()) {
			//        	// because JsonConvert makes all integers Int64
			//        	oldVersion = vtype.getConstructor(oldVersion.getClass()).newInstance(oldVersion);
			//        } 
			classMeta.setPropertyValue(entity, vname, oldVersion);
		}
	}

	/**
	 * Update the KeyMappings with their real values.
	 * @param entitiesWithAutoGeneratedKeys
	 * @return
	 */
	private List<KeyMapping> updateAutoGeneratedKeys(List<EntityInfo> entitiesWithAutoGeneratedKeys) {
		List<KeyMapping> list = new ArrayList<KeyMapping>();
		for (EntityInfo entityInfo : entitiesWithAutoGeneratedKeys) {
			KeyMapping km = entityKeyMapping.get(entityInfo);
			if (km != null && km.getTempValue() != null) {
				Object entity = entityInfo.entity;
				Object id = getIdentifier(entity, null);
				km.setRealValue(id);
				list.add(km);
			}
		}
		return list;
	}

}
