using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Breeze.NetClient;
using Breeze.Core;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Foo;

namespace Test_NetClient {

  [TestClass]
  public class AttachTests {

    private Task<EntityManager> _emTask = null;
    private EntityManager _em1;
    private static MetadataStore __metadataStore;

    [TestInitialize]
    public void TestInitializeMethod() {
      _emTask = SetUpAsync();
    }

    public async Task<EntityManager> SetUpAsync() {
      var serviceName = "http://localhost:7150/breeze/NorthwindIBModel/";
      
      if (__metadataStore == null) {
        _em1 = new EntityManager(serviceName);
        await _em1.FetchMetadata();
        __metadataStore = _em1.MetadataStore;
      } else {
        _em1 = new EntityManager(serviceName, __metadataStore);
      }
      return _em1;
      
    }

    [TestCleanup]
    public void TearDown() {
      
    }

    [TestMethod]
    public async Task RejectChanges() {
      await _emTask;


      var prod1 = new Product();
      prod1.Discontinued = true;
      _em1.AttachEntity(prod1, EntityState.Unchanged);
      prod1.Discontinued = false;
      prod1.EntityAspect.RejectChanges();
      
      Assert.IsTrue(prod1.Discontinued == true, "should have returned to initial state");
    }

    [TestMethod]
    public async Task CreateEntity() {
      await _emTask;

      var emp1 = _em1.CreateEntity(typeof(Employee));
      Assert.IsTrue(emp1.EntityAspect.EntityState == EntityState.Added);
      var emp3 = _em1.CreateEntity<Employee>(EntityState.Detached);
      emp3.LastName = "Smith";
      Assert.IsTrue(emp3.EntityAspect.EntityState.IsDetached());
      Assert.IsTrue(emp3.LastName == "Smith");
    }

    [TestMethod]
    public async Task AttachEntityDefaultValues() {
      // Default values when entity is first created.
      await _emTask;
      var employeeType = _em1.MetadataStore.GetEntityType(typeof(Employee));
      var empIdProp = employeeType.GetDataProperty(TestFns.EmployeeKeyName);

      var emp = _em1.CreateEntity<Employee>(EntityState.Unchanged);
      Assert.IsTrue(emp.EmployeeID == 0, "id should be zero at creation");
      var agkType = employeeType.AutoGeneratedKeyType;
      emp.EntityAspect.Detach();
      Assert.IsTrue(emp.EntityAspect.IsDetached);
      // manager should NOT replace '0' with generated temp id 
      _em1.AttachEntity(emp, EntityState.Unchanged);
      Assert.IsTrue(emp.EmployeeID == 0, "should still be 0");
      emp.EntityAspect.Detach();
      _em1.AttachEntity(emp, EntityState.Added);
      Assert.IsTrue(emp.EmployeeID != 0, "should not be be 0");
    }

    [TestMethod]
    public async Task AddToNavSet() {
      
        await _emTask;
        
        var customer = new Customer();
        var order = new Order();
        _em1.AttachEntity(customer);
        var origOrders = customer.Orders;
        Assert.IsTrue(origOrders.Count == 0);
        origOrders.Add(order);
        // next line won't compile - this is good!
        // customer.Orders = new NavigationSet<Order>();
        Assert.IsTrue(origOrders.Count == 1);
        Assert.IsTrue(customer.Orders == origOrders, "should be same collection");
        Assert.IsTrue(order.EntityAspect.IsAttached, "should be attached");
        Assert.IsTrue(order.Customer == customer, "order.Customer should = customer");
    }
    
    //test("cannot attach an entity created by a different metadataStore", 1, function () {
    //    var em = newEm();
    //    var customerType = em.metadataStore.getEntityType("Customer");
    //    var customer = customerType.createEntity();
    //    var newMs = MetadataStore.importMetadata(em.metadataStore.exportMetadata());
    //    var em2 = newEm(newMs);
    //    try {
    //        em2.attachEntity(customer);
    //        ok(false, "should not get here");
    //    } catch (e) {
    //        ok(e.message.indexOf("MetadataStore"));
    //    }
        
    //});

     // can attach a detached entity to a different manager via attach/detach
    [TestMethod]
    public async Task AttachToDifferentManager() {
      await _emTask;

      var cust = _em1.CreateEntity<Customer>(EntityState.Unchanged);
      var order = _em1.CreateEntity<Order>(EntityState.Unchanged);
      cust.Orders.Add(order);
      Assert.IsTrue(cust.Orders.Count == 1);
      var em2 = new EntityManager(_em1);
      try {
        em2.AttachEntity(cust);
        Assert.Fail("should not get here");
      } catch {
        // expected
      }

      _em1.DetachEntity(cust);
      Assert.IsTrue(order.Customer == null);
      Assert.IsTrue(cust.Orders.Count == 0);
      em2.AttachEntity(cust);
      Assert.IsTrue(cust.EntityAspect.EntityManager == em2);

    }
    
    // can attach a detached entity to a different manager via clear
    [TestMethod]
    public async Task AttachEmViaDetach() {
      await _emTask;

        var cust = new Customer();
        cust.EntityAspect.SetValue(TestFns.CustomerKeyName, Guid.NewGuid());
        Assert.IsTrue(cust.EntityAspect.IsDetached, "should be detached");
        _em1.AttachEntity(cust);
        Assert.IsTrue(cust.EntityAspect.IsAttached, "should be attached");
        _em1.Clear(); // will detach cust

        Assert.IsTrue(cust.EntityAspect.IsDetached, "should be detached - again");
        Assert.IsTrue(cust.EntityAspect.EntityManager == _em1, "should still be associated with em1");
        // therefore this should be ok
        var em2 = new EntityManager(_em1);
        em2.AttachEntity(cust);
        Assert.IsTrue(cust.EntityAspect.EntityManager == em2, "should be on em2");
    }

    
    // setting child's parent entity null removes it from old parent
    [TestMethod]
    public async Task SetParentEntityToNull() {
      await _emTask;

      var cust = _em1.CreateEntity<Customer>(EntityState.Unchanged);
      var order = _em1.CreateEntity<Order>();
      order.Customer = cust;
      Assert.IsTrue(order.Customer == cust, "should be set");
      Assert.IsTrue(cust.Orders.First() == order, "should be part of collection" );
      order.Customer = null;
      Assert.IsTrue(order.Customer == null, "should not be set");
      Assert.IsTrue(cust.Orders.Count == 0, "should not be part of collection" );

    }

    // unidirectional attach - n->1
    [TestMethod]
    public async Task UnidirectionalAttachFk() {
      await _emTask;
      if (TestFns.DEBUG_MONGO) {
        Assert.Inconclusive("NA for Mongo - Order/OrderDetail");
        return;
      }

      var od1 = new OrderDetail();
      var prod1 = new Product();
      od1.ProductID = -99;
      _em1.AttachEntity(od1);
      _em1.AttachEntity(prod1);
      Assert.IsTrue(od1.Product == null, "Product should be null");
      prod1.ProductID = 2;
      od1.ProductID = 2;
      Assert.IsTrue(od1.Product == prod1, "should now point to product");

      var od2 = new OrderDetail();
      var prod2 = new Product();
      od2.ProductID = -88;
      _em1.AttachEntity(od2);
      _em1.AttachEntity(prod2);
      Assert.IsTrue(od2.Product == null, "Product should be null - again");
      // same as above but different order
      od2.ProductID = 3;
      // should now have an unresolved parent.
      prod2.ProductID = 3;
      
      Assert.IsTrue(od2.Product == prod2, "should now point to product - again");
    }


    // unidirectional attach - 1->n
    [TestMethod]
    public async Task UnidirectionalAttach1ToN() {
      await _emTask;

      if (TestFns.DEBUG_MONGO || TestFns.DEBUG_ODATA) {
        Assert.Inconclusive( "NA for Mongo or OData - TimeList and Timegroup not yet added");
      }
      
      var tl1 = _em1.CreateEntity<TimeLimit>();
      var tl2 = _em1.CreateEntity<TimeLimit>();
      var tg1 = _em1.CreateEntity<TimeGroup>();
      var id1 = tg1.Id;
      tl1.TimeGroupId = id1;
      Assert.IsTrue(tg1.TimeLimits.Count == 1 
        && tg1.TimeLimits.Contains(tl1), "should be connected");
      tl2.TimeGroupId = id1;
      Assert.IsTrue(tg1.TimeLimits.Count == 2 
        && tg1.TimeLimits.Contains(tl2), "another should be connected");

    
    }

    // unidirectional attach - 1->n
    [TestMethod]
    public async Task UnidirectionalAttach1ToN_v2() {
      await _emTask;

      if (TestFns.DEBUG_MONGO || TestFns.DEBUG_ODATA) {
        Assert.Inconclusive( "NA for Mongo or OData - TimeList and Timegroup not yet added");
      }
      
      var tl1 = _em1.CreateEntity<TimeLimit>();
      var tl2 = _em1.CreateEntity<TimeLimit>();
      var tg1 = _em1.CreateEntity<TimeGroup>();
      Assert.IsTrue(tg1.TimeLimits.Count == 0, "should be no Timelimits");
      tg1.TimeLimits.Add(tl1);
      Assert.IsTrue(tg1.TimeLimits.Count == 1 
        && tg1.TimeLimits.Contains(tl1), "should be connected");
      tg1.TimeLimits.Add(tl2);
      Assert.IsTrue(tg1.TimeLimits.Count == 2 
        && tg1.TimeLimits.Contains(tl2), "another should be connected");

      // add 1 that is already there
      tg1.TimeLimits.Add(tl1);
      Assert.IsTrue(tg1.TimeLimits.Count == 2 
        && tg1.TimeLimits.Contains(tl1), "length should not change when adding a dup");
    }

    // primary key fixup
    [TestMethod]
    public async Task PrimaryKeyFixup() {
      await _emTask;

      var prod = new Product();
      _em1.AttachEntity(prod);
      var origProdId = prod.ProductID;
      var ek = prod.EntityAspect.EntityKey;
      var sameProd = _em1.FindEntityByKey(ek);
      Assert.IsTrue(prod == sameProd, "should be the same product");
      var sameProd2 = _em1.FindEntityByKey<Product>(origProdId);
      Assert.IsTrue(prod == sameProd2, "should be the same product-again");
      prod.ProductID = 7;
      var notSameProd = _em1.FindEntityByKey(ek);
      Assert.IsTrue(notSameProd == null);
      var sameProd3 = _em1.FindEntityByKey(prod.EntityAspect.EntityKey);
      Assert.IsTrue(prod == sameProd2, "should be the same product-again 2");
    }
    
    // changing FK to null removes it from old parent
    [TestMethod]
    public async Task FkSetToNull() {
      await _emTask;

      var cust = _em1.CreateEntity<Customer>(EntityState.Unchanged);
      var order1 = _em1.CreateEntity<Order>();
      order1.Customer = cust;
      Assert.IsTrue(order1.Customer == cust, "should be customer");
      Assert.IsTrue(cust.Orders.Contains(order1), "should contain order1");

      var order2 = new Order();
      order2.Customer = cust;
      Assert.IsTrue(order2.EntityAspect.IsAttached && order2.EntityAspect.EntityState.IsAdded());
      Assert.IsTrue(order2.Customer == cust, "should be customer - again");
      Assert.IsTrue(cust.Orders.Contains(order2), "should contain order2");

      order1.CustomerID = null;
      Assert.IsTrue(order1.Customer == null, "should be null");
      Assert.IsTrue(!cust.Orders.Contains(order1), "should not contain order1");

    }

    
    // add, detach and readd
    [TestMethod]
    public async Task AddDetachReadd() {
      await _emTask;

      var order = _em1.CreateEntity<Order>();
      Assert.IsTrue(order.EntityAspect.IsAttached && order.EntityAspect.EntityState.IsAdded());
      _em1.DetachEntity(order);
      Assert.IsTrue(order.EntityAspect.IsDetached);
      _em1.AttachEntity(order, EntityState.Added);
      Assert.IsTrue(order.EntityAspect.IsAttached && order.EntityAspect.EntityState.IsAdded());
    }

    // attach, detach and reattach
    [TestMethod]
    public async Task AttachDetachReattach() {
      await _emTask;

      var order = _em1.CreateEntity<Order>(EntityState.Unchanged);
      Assert.IsTrue(order.EntityAspect.IsAttached && order.EntityAspect.EntityState.IsUnchanged());
      _em1.DetachEntity(order);
      Assert.IsTrue(order.EntityAspect.IsDetached);
      _em1.AttachEntity(order);
      Assert.IsTrue(order.EntityAspect.IsAttached && order.EntityAspect.EntityState.IsUnchanged());
    }
    
    // exception if set nav to entity with different manager
    [TestMethod]
    public async Task ErrorOnNavAttach() {
      await _emTask;
    
      var order = _em1.CreateEntity<Order>(EntityState.Unchanged);
    
      var em2 = new EntityManager(_em1);
      var cust = em2.CreateEntity<Customer>(EntityState.Unchanged);
      Assert.IsTrue(order.EntityAspect.EntityManager != cust.EntityAspect.EntityManager, "should not be the same manager");
      try {
        order.Customer = cust;
        Assert.Fail("should not get here");
      } catch (Exception e) {
        Assert.IsTrue(e.Message.Contains("EntityManager"), "message should mention 'EntityManager'");
      }
      cust.EntityAspect.Detach();
      order.Customer = cust;
      Assert.IsTrue(order.EntityAspect.EntityManager == cust.EntityAspect.EntityManager, "should be the same manager");
      Assert.IsTrue(cust.Orders.Contains(order) && order.Customer == cust, "should be properly connected");
    }

    // exception if set nav to entity with different manager
    [TestMethod]
    public async Task ErrorOnAttachMultiple() {
      await _emTask;
    
      var order = _em1.CreateEntity<Order>(EntityState.Unchanged);
      var em2 = new EntityManager(_em1);
      try {
        em2.AttachEntity(order);
        Assert.Fail("should not get here");
      } catch (Exception e) {
        Assert.IsTrue(e.Message.Contains("EntityManager"), "message should mention 'EntityManager'");
      }
    }
      
       
    //test("rejectChanges on added entity", function () {
    //    var em = newEm();
    //    //var typeInfo = em.metadataStore.getEntityType("Order");
    //    //var newEntity = typeInfo.createEntity();
    //    //em.addEntity(newEntity);
    //    var newEntity = em.createEntity("Order");

    //    var entityState = newEntity.entityAspect.entityState;
    //    ok(entityState.isAdded(),
    //        "newEntity should be in Added state; is "+entityState);

    //    newEntity.entityAspect.rejectChanges();
     
    //    entityState = newEntity.entityAspect.entityState;
    //    ok(entityState.isDetached(),
    //        "newEntity should be Detached after rejectChanges; is "+entityState);

    //    ok(!em.hasChanges(), "should not have changes");

    //    var inCache = em.getEntities(), count = inCache.length;
    //    ok(count == 0, "should have no entities in cache; have " + count);

    //});
    
    //test("delete added entity", 3, function () {
    //    var em = newEm();
    //    var typeInfo = em.metadataStore.getEntityType("Order");
    //    //var newEntity = typeInfo.createEntity();
    //    //em.addEntity(newEntity);
    //    var newEntity = em.createEntity(typeInfo);

    //    ok(newEntity.entityAspect.entityState.isAdded(),
    //        "new Todo added to cache is in 'added' state");

    //    newEntity.entityAspect.setDeleted();

    //    ok(newEntity.entityAspect.entityState.isDetached(),  // FAIL
    //        "new Todo added to cache is 'detached'");  
        
    //    // get the first (and only) entity in cache
    //    equal(em.getEntities().length, 0, "no entities in cache"); //FAIL

    //});


    //test("add entity - no key", function () {
    //    if (testFns.DEBUG_MONGO) {
    //        ok(true, "NA for Mongo - OrderDetail");
    //        return;
    //    }
    //    var em = newEm();
    //    var odType = em.metadataStore.getEntityType("OrderDetail");
    //    var od = odType.createEntity();
    //    try {
    //        em.addEntity(od);
    //        ok(false, "should not be able to attach an entity without setting its key");
    //    } catch (e) {
    //        ok(e.message.indexOf("key") >= 0, "error message should contain 'key'");
    //    }
    //    try {
    //        var cId = em.generateTempKeyValue(od);
    //        ok(false, "should not be able to generate a temp multipart key");
    //    } catch (e) {
    //        ok(e.message.indexOf("multipart keys") >= 0, "error message should contain 'multipart keys'");
    //    }
    //    // only need to set part of the key
    //    od.setProperty("orderID", 999);
    //    em.addEntity(od);
    //});

    //test("add entity - no key 2", function () {
    //    if (testFns.DEBUG_MONGO) {
    //        ok(true, "NA for Mongo - OrderDetail");
    //        return;
    //    }
    //    var em = newEm();
    //    var od;
    //    try {
    //        od = em.createEntity("OrderDetail");
    //        ok(false, "should not be able to attach an entity without setting its key");
    //    } catch (e) {
    //        ok(e.message.indexOf("key") >= 0, "error message should contain 'key'");
    //    }
    //    try {
    //        od = em.createEntity("OrderDetail", null, EntityState.Detached);
    //        var cId = em.generateTempKeyValue(od);
    //        ok(false, "should not be able to generate a temp multipart key");
    //    } catch (e) {
    //        ok(e.message.indexOf("multipart keys") >= 0, "error message should contain 'multipart keys'");
    //    }
    //    // only need to set part of the key
    //    od.setProperty("orderID", 999);
    //    em.addEntity(od);
    //});


    //test("add child", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();
        
    //    em.addEntity(cust1);
    //    ok(cust1.entityAspect.entityState === EntityState.Added, "cust entityState should be added");
    //    ok(cust1.entityAspect.hasTempKey === true, "hasTempKey should be true");
    //    var orders = cust1.getProperty("orders");

    //    var changeArgs = null;
    //    orders.arrayChanged.subscribe(function (args) {
    //        changeArgs = args;
    //    });
    //    orders.push(order1);
    //    ok(cust1.entityAspect.entityState === EntityState.Added, "cust entityState should be added");
    //    ok(order1.entityAspect.entityState === EntityState.Added, " order entityState should be added");
    //    ok(orders.parentEntity == cust1);
    //    var navProperty = cust1.entityType.getProperty("orders");
    //    ok(orders.navigationProperty == navProperty);
    //    ok(changeArgs.added, "changeArgs not set");
    //    ok(changeArgs.added[0] === order1, "changeArgs added property not set correctly");
    //    var sameCust = order1.getProperty("customer");
    //    ok(sameCust === cust1, "inverse relationship not setPropertiesd");
        
    //});

    //test("detach child", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();
    //    var order2 = orderType.createEntity();

    //    em.addEntity(cust1);
    //    ok(cust1.entityAspect.entityState === EntityState.Added, "cust entityState should be added");
    //    var orders = cust1.getProperty("orders");
    //    orders.push(order1);
    //    orders.push(order2);
    //    var arrayChangeCount = 0;
    //    orders.arrayChanged.subscribe(function (args) {
    //        arrayChangeCount += 1;
    //        if (args.removed[0] !== order2) {
    //            ok(false, "should not have gotten here");
    //        }
    //    });
    //    var order2ChangeCount = 0;
    //    order2.entityAspect.propertyChanged.subscribe(function (args2) {
    //        ok(args2.entity === order2, "args2.entity === order2");
    //        if (args2.propertyName === "customer") {
    //            order2ChangeCount += 1;
    //        } else if (args2.propertyName === "customerID") {
    //            order2ChangeCount += 1;
    //        } else {
    //            ok(false, "should not have gotten here");
    //        }
    //    });
    //    var orders2 = cust1.getProperty("orders");
    //    ok(orders === orders2,"orders should === orders2");
    //    var ix = orders.indexOf(order2);
    //    orders.splice(ix, 1);
    //    ok(orders.length === 1, "should only be 1 order");
    //    ok(arrayChangeCount === 1, "arrayChangeCount should be 1");
    //    ok(order2ChangeCount === 2, "order2ChangeCount should be 2");

    //    var sameCust = order2.getProperty("customer");
    //    ok(sameCust === null, "order2.Customer should now be null");
    //});

    //test("add parent", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();


    //    em.addEntity(order1);
    //    ok(order1.entityAspect.entityState.isAdded(), "order entityState should be added");
    //    var emptyCust = order1.getProperty("customer");
    //    ok(!emptyCust);
    //    var changeArgs = null;
    //    order1.entityAspect.propertyChanged.subscribe(function (args) {
    //        changeArgs = args;
    //    });
    //    order1.setProperty("customer", cust1);
    //    ok(order1.entityAspect.entityState.isAdded(), "order entityState should be added");
    //    ok(cust1.entityAspect.entityState.isAdded(), "customer entityState should be added");
    //    ok(changeArgs, "no property notification occured");
    //    ok(changeArgs.propertyName === "customer");
    //    ok(changeArgs.newValue === cust1, "changeArgs.newValue not set correctly");
    //    ok(changeArgs.oldValue === null, "changeArgs.oldValue not set correctly");
    //    var orders = cust1.getProperty("orders");
    //    ok(orders[0] == order1, "inverse relationship not setPropertiesd");

    //});

    //test("change parent (1-n)", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var cust2 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState.isUnchanged(), "order1 should be 'unchanged'");
    //    order1.setProperty("customer", cust1);
    //    ok(cust1.entityAspect.entityState.isAdded(), "cust1 should be 'added'");
    //    var cust1Orders = cust1.getProperty("orders");
    //    ok(cust1Orders.length === 1, "There should be exactly one order in cust1Orders");
    //    ok(cust1Orders.indexOf(order1) >= 0, "order1 should be in cust1.Orders");

    //    // now change
    //    order1.setProperty("customer", cust2);
    //    ok(cust2.entityAspect.entityState.isAdded(), "cust2 should be added");
    //    var cust2Orders = cust2.getProperty("orders");
    //    ok(cust2Orders.length === 1, "There should be exactly one order in cust1Orders");
    //    ok(cust2Orders.indexOf(order1) >= 0, "order1 should be in cust2.Orders");
    //    ok(cust1Orders === cust1.getProperty("orders"), "cust1.Orders should be the same collection object as that returned earlier")
    //    ok(cust1Orders.indexOf(order1) == -1, "order1 should no longer be in cust1.Orders");
    //    ok(order1.getProperty("customer") == cust2, "order1.Customer should now be cust2");

    //});

    //test("change child (1-n)", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var cid1 = em.generateTempKeyValue(cust1);
    //    var cust2 = custType.createEntity();
    //    var cid2 = em.generateTempKeyValue(cust2);
    //    var order1 = orderType.createEntity();

    //    em.attachEntity(cust1);

    //    ok(cust1.entityAspect.entityState.isUnchanged(), "cust1 should be 'unchanged'");
    //    var cust1Orders = cust1.getProperty("orders");
    //    cust1Orders.push(order1);
    //    ok(cust1Orders.length === 1, "There should be exactly one order in cust1Orders");

    //    ok(order1.entityAspect.entityState.isAdded(), "order1 should be 'added'");
    //    ok(cust1Orders.indexOf(order1) >= 0, "order1 should be in cust1.Orders");
    //    // now change
    //    var cust2Orders = cust2.getProperty("orders");
    //    cust2Orders.push(order1);
    //    ok(cust2Orders.length === 1, "There should be exactly one order in cust2Orders");
    //    ok(cust1Orders.length === 0, "There should be no orders in cust1Orders")
    //    ok(cust2.entityAspect.entityState.isAdded(), "cust2 should be 'added'");
    //    ok(cust2Orders.indexOf(order1) >= 0, "order1 should be in cust2.Orders");
    //    ok(cust1Orders === cust1.getProperty("orders"), "cust1.Orders should be the same collection object as that returned earlier");
    //    ok(cust1Orders.indexOf(order1) == -1, "order1 should no longer be in cust1.Orders");
    //    ok(order1.getProperty("customer") == cust2, "order1.Customer should now be cust2");

    //});

    //test("graph attach (1-n) - setProperties child, attach child", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    order1.setProperty("customer", cust1);
    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState === EntityState.Unchanged, "order entityState should be unchanged");
    //    ok(cust1.entityAspect.entityState === EntityState.Unchanged, "customer entityState should be unchanged");
    //    var orders = cust1.getProperty("orders");
    //    ok(orders[0] == order1, "inverse relationship not set");
    //    ok(orders[0].getProperty("customer") === cust1, "order.Customer not set");
    //});

    //test("graph attach (1-n)- setProperties child, attach parent", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    order1.setProperty("customer", cust1);
    //    em.attachEntity(cust1);
    //    ok(order1.entityAspect.entityState === EntityState.Unchanged, "order entityState should be unchanged");
    //    ok(cust1.entityAspect.entityState === EntityState.Unchanged, "customer entityState should be unchanged");
    //    var orders = cust1.getProperty("orders");
    //    ok(orders[0] == order1, "inverse relationship not setProperties");
    //});

    //test("graph attach (1-n) - setProperties parent, attach parent", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    var cust1Orders = cust1.getProperty("orders");
    //    cust1Orders.push(order1);
    //    ok(cust1Orders.length === 1, "There should be exactly one order in cust1Orders");
    //    em.attachEntity(cust1);
    //    ok(order1.entityAspect.entityState === EntityState.Unchanged, "order entityState should be unchanged");
    //    ok(cust1.entityAspect.entityState === EntityState.Unchanged, "customer entityState should be unchanged");
    //    ok(order1.getProperty("customer") === cust1, "inverse relationship not setPropertiesd");
    //});

    //test("graph attach (1-n) - setProperties parent, attach child", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    var cust1Orders = cust1.getProperty("orders");
    //    cust1Orders.push(order1);
    //    ok(cust1Orders.length === 1, "There should be exactly one order in cust1Orders");
    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState === EntityState.Unchanged, "order entityState should be unchanged");
    //    ok(cust1.entityAspect.entityState === EntityState.Unchanged, "customer entityState should be unchanged");
    //    ok(order1.getProperty("customer") === cust1, "inverse relationship not setPropertiesd");
    //});

    //test("graph attach (1-n) - parent detach", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var order1 = orderType.createEntity();

    //    var cust1Orders = cust1.getProperty("orders");
    //    cust1Orders.push(order1);
    //    ok(cust1Orders.length === 1, "There should be exactly one order in cust1Orders");
    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState === EntityState.Unchanged, "order entityState should be unchanged");
    //    ok(cust1.entityAspect.entityState === EntityState.Unchanged, "customer entityState should be unchanged");
    //    ok(order1.getProperty("customer") === cust1, "inverse relationship not setProperties");
    //    var orderCustId =  order1.getProperty(testFns.customerKeyName);
    //    em.detachEntity(cust1);
    //    ok(cust1.entityAspect.entityState.isDetached(), "should be detached");
    //    ok(order1.entityAspect.entityState.isUnchanged(), "should be unchanged");
    //    var orderCustId2 = order1.getProperty(testFns.customerKeyName);
    //    ok(orderCustId === orderCustId2, "custId should not have changed");


    //});

    //test("graph attach (1-n) - piecewise", function () {
    //    if (testFns.DEBUG_MONGO) {
    //        ok(true, "NA for Mongo - OrderDetail");
    //        return;
    //    }
    //    var em = newEm();
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var orderDetailType = em.metadataStore.getEntityType("OrderDetail");

    //    var order = orderType.createEntity();
    //    ok(order.entityAspect.entityState.isDetached(), "order should be 'detached");

    //    order.setProperty("orderID", 888);

    //    em.attachEntity(order);
    //    var orderId = order.getProperty("orderID");
    //    ok(orderId);
    //    ok(order.entityAspect.entityState.isUnchanged(), "order should be 'unchanged'");
    //    for (var i = 0; i < 3; i++) {
    //        var od = orderDetailType.createEntity();
    //        od.setProperty("productID", i + 1); // part of pk && not the default value
    //        order.getProperty("orderDetails").push(od);
    //        ok(od.entityAspect.entityState.isAdded(), "orderDetail should be 'added");
    //        ok(od.getProperty("order") === order, "orderDetail.order not set");
    //        ok(od.getProperty("orderID") === orderId, "orderDetail.orderId not set");
    //    }
    //});

    //// TODO: will not yet work if both order and orderDetail keys are autogenerated.
    //test("graph attach (1-n)- all together", function () {
    //    if (testFns.DEBUG_MONGO) {
    //        ok(true, "NA for Mongo - OrderDetail");
    //        return;
    //    }
    //    var em = newEm();
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var orderDetailType = em.metadataStore.getEntityType("OrderDetail");
        
    //    var order = orderType.createEntity();
    //    ok(order.entityAspect.entityState.isDetached(), "order should be 'detached");
    //    order.setProperty("orderID", 999);

    //    for (var i = 0; i < 3; i++) {
    //        var od = orderDetailType.createEntity();
    //        od.setProperty("productID", i + 1); // part of pk and not the default value
    //        order.getProperty("orderDetails").push(od);
    //        ok(od.entityAspect.entityState.isDetached(), "orderDetail should be 'detached");
    //    }
    //    em.attachEntity(order);
    //    var orderId = order.getProperty("orderID");
    //    ok(orderId);
    //    ok(order.entityAspect.entityState.isUnchanged(), "order should be 'unchanged'");
    //    order.getProperty("orderDetails").forEach(function (od) {
    //        ok(od.getProperty("order") === order, "orderDetail.order not set");
    //        ok(od.getProperty("orderID") === orderId, "orderDetail.orderId not set");
    //        ok(od.entityAspect.entityState.isUnchanged(), "orderDetail should be 'unchanged");
    //    });
    //});

    //test("graph attach (1-n) - all together - autogenerated", function () {
    //    if (testFns.DEBUG_MONGO) {
    //        ok(true, "NA for Mongo - OrderDetail");
    //        return;
    //    }
    //    var em = newEm();
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var orderDetailType = em.metadataStore.getEntityType("OrderDetail");

    //    var order = orderType.createEntity();
    //    ok(order.entityAspect.entityState.isDetached(), "order should be 'detached");
    //    order.setProperty("orderID", 999);

    //    for (var i = 0; i < 3; i++) {
    //        var od = orderDetailType.createEntity();
    //        od.setProperty("productID", i); // part of pk
    //        order.getProperty("orderDetails").push(od);
    //        ok(od.entityAspect.entityState.isDetached(), "orderDetail should be 'detached");
    //    }
    //    em.attachEntity(order);
    //    ok(order.entityAspect.entityState.isUnchanged(), "order should be 'unchanged'");
    //    var orderId = order.getProperty("orderID");
    //    ok(orderId);
    //    order.getProperty("orderDetails").forEach(function (od) {
    //        ok(od.getProperty("order") === order, "orderDetail.order not set");
    //        ok(od.getProperty("orderID") === orderId, "orderDetail.orderId not set");
    //        ok(od.entityAspect.entityState.isUnchanged(), "orderDetail should be 'unchanged");
    //    });
    //});


    //test("duplicate entity keys", function () {
    //    var em = newEm();

    //    var cust1 = em.createEntity("Customer", null, EntityState.Detached);
    //    var cust2 = em.createEntity("Customer", null, EntityState.Detached);

    //    em.attachEntity(cust1);
    //    try {
    //        var cust1Id = cust1.getProperty(testFns.customerKeyName);
    //        cust2.setProperty(testFns.customerKeyName, cust1Id);
    //        em.attachEntity(cust2);
    //        ok(false, "should not be able to attach 2 entities with the same key");
    //    } catch (e) {
    //        ok(e.message.indexOf("key") >= 0);
    //    }

    //});

    //test("fk fixup - fk to nav - attached", function () {
    //    var em = newEm();
        
    //    var cust1 = em.createEntity("Customer", null, EntityState.Detached);
    //    var cust2 = em.createEntity("Customer", null, EntityState.Detached);
    //    var order1 = em.createEntity("Order", null, EntityState.Detached);

    //    em.attachEntity(order1);
    //    em.attachEntity(cust1);
    //    var custIdValue = cust1.getProperty(testFns.customerKeyName);
    //    order1.setProperty("customerID", custIdValue);
    //    var orderCustomer = order1.getProperty("customer");
    //    ok(orderCustomer === cust1, "nav property fixup did not occur");

    //});

    //test("fk fixup - nav to fk - attached", function () {
    //    var em = newEm();
    //    var cust1 = em.createEntity("Customer", null, EntityState.Detached);
    //    var cust2 = em.createEntity("Customer", null, EntityState.Detached);
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var order1 = em.createEntity(orderType, null, EntityState.Detached);

    //    em.attachEntity(order1);
    //    em.attachEntity(cust1);

    //    order1.setProperty("customer", cust1);
    //    var orderCustId = order1.getProperty("customerID");
    //    var custId = cust1.getProperty(testFns.customerKeyName);
    //    ok(orderCustId === custId, "fk property fixup did not occur");

    //});

    //test("fk fixup - unattached children", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var c1Id = em.generateTempKeyValue(cust1);
    //    var cust2 = custType.createEntity();
    //    var order1 = orderType.createEntity();
    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState.isUnchanged(), "order1 entityState should be 'unchanged'");
    //    // assign an fk where the parent doesn't yet exist on  this em.
    //    order1.setProperty("customerID", c1Id);
    //    ok(order1.entityAspect.entityState.isModified(), "order1 entityState should be 'modfied'");
    //    order1.entityAspect.acceptChanges();
    //    ok(order1.entityAspect.entityState.isUnchanged(), "order1 entityState should be 'unchanged'");
    //    var order1Cust = order1.getProperty("customer");
    //    ok(order1Cust == null, "order1.Customer should be null at this point.");
    //    em.attachEntity(cust1);
    //    order1Cust = order1.getProperty("customer");
    //    ok(order1Cust !== null, "order1.Customer should have been fixed up");
    //    ok(order1.entityAspect.entityState.isUnchanged(), "fixup should not change the entity state");
    //});

    //test("fk fixup - unattached parent pushes attached child", function () {
    //    var em = newEm();
    //    var custType = em.metadataStore.getEntityType("Customer");
    //    var orderType = em.metadataStore.getEntityType("Order");
    //    var cust1 = custType.createEntity();
    //    var c1Id = em.generateTempKeyValue(cust1);
    //    var cust2 = custType.createEntity();
    //    var order1 = orderType.createEntity();
    //    em.attachEntity(order1);
    //    ok(order1.entityAspect.entityState.isUnchanged(), "order1 entityState should be 'unchanged'");
    //    ok(cust1.entityAspect.entityState.isDetached(), "cust1 entityState should be 'detached'");
    //    var order1Cust = order1.getProperty("customer");
    //    ok(order1Cust == null, "order1.Customer should be null at this point.");
    //    var cust1Orders = cust1.getProperty("orders");
    //    cust1Orders.push(order1);
    //    ok(order1.entityAspect.entityState.isModified(), "order1 entityState should be 'modified'");
    //    ok(cust1.entityAspect.entityState.isAdded(), "order1 entityState should be 'added'");
    //    order1Cust = order1.getProperty("customer");
    //    ok(order1Cust !== null, "order1.Customer should have been fixed up");
    //    var order1CustId = order1.getProperty("customerID");
    //    var custId = cust1.getProperty(testFns.customerKeyName);
    //    ok(order1CustId === custId, "fk property fixup did not occur");

    //});

    //test("recursive navigation fixup", function () {
    //    var em = newEm();
    //    var empType = em.metadataStore.getEntityType("Employee");
    //    var emp1 = em.createEntity("Employee", null, EntityState.Detached);
    //    var emp2 = em.createEntity("Employee", null, EntityState.Detached);
    //    var emp3 = em.createEntity("Employee", null, EntityState.Detached);
        
        
    //    ok(emp1.entityAspect.entityState.isDetached(), "emp1 should be detached");
    //    ok(emp2.entityAspect.entityState.isDetached(), "emp2 should be detached");
    //    ok(emp3.entityAspect.entityState.isDetached(), "emp3 should be detached");
    //    emp2.setProperty("manager", emp1);
    //    emp2.getProperty("directReports").push(emp3);
    //    em.addEntity(emp3);
    //    ok(emp1.entityAspect.entityState.isAdded(), "emp1 should be unchanged");
    //    ok(emp2.entityAspect.entityState.isAdded(), "emp2 should be unchanged");
    //    ok(emp3.entityAspect.entityState.isAdded(), "emp3 should be unchanged");
    //    var emp1Id = emp1.getProperty(testFns.employeeKeyName);
    //    var emp2Id = emp2.getProperty(testFns.employeeKeyName);
    //    var emp3Id = emp3.getProperty(testFns.employeeKeyName);
    //    ok(emp2.getProperty("reportsToEmployeeID") === emp1Id, "emp2.ReportsTo... not set properly");
    //    ok(emp3.getProperty("reportsToEmployeeID") === emp2Id, "emp2.ReportsTo... not set properly");
    //    ok(emp2.getProperty("directReports")[0] === emp3, "emp2.DirectReports not set properly");
    //    ok(emp1.getProperty("directReports")[0] === emp2, "emp1.DirectReports not set properly");

    //});
  }
}
